\newcommand{\projectName}{Az EGTIB}

\chapter{\projectName{} bemutatása}

\projectName{} projekt célja egy olyan felhasználóbarát felület létrehozása, mely lehetőséget teremt a daganatos sejtek játékelméleti modellezésére és szimulációjára, a szimulációs eredmények megjelenítésére illetve ezeknek valamilyen szintű mentésére is. Ezért született meg, a mai trendeket figyelembe véve, egy kliens-szerver architektúrán alapuló webalkalmazás, mely részben az \cite{archetti2016cooperation}-ben megjelent modellt implementálja, és ahhoz új funkcionalitásokat is hozzáad.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.98\linewidth]{images/welcomePage}
	\vspace*{1mm}
	\caption{Főoldal}
	\label{fig:welcomePage}
\end{figure}

\section{Funkcionalitások}

Az alkalmazásunkat egy főoldalra, valamint funkcionalitás szerint, három fő komponensre oszthatjuk:

\paragraph{Üdvözlő oldal}- ezen az oldalon kaptak helyet az általános jellegű információk és egy boostrap carousel, amellyel az alkalmazás mindegyik fő komponense rövid és humoros szövegekkel van bemutatva, valamint egy kép amely tovább visz az adott oldalra (Ábra \ref{fig:welcomePage})

\paragraph{Vizualizáció}- a vizualizációs oldalra tévedve (\ref{fig:VisualizationDiagram}), a felhasználó elég sok újdonsággal találja magát szemben. Az legszembeötlőbb egy színes pöttyökkel teli rajz lesz, ami a Voronoi diagram. Itt a kooperáló és defektáló sejtek narancssárga illetve sötétbarna színben vannak reprezentálva. A képernyő második legnagyobb részét a diagramtól balra elhelyezkedő paraméterlista tölti ki. Itt a következő paramétereket lehet állítgatni, amelyek a szimulációt befolyásolják:
\begin{itemize}
	\item kezdeti populáció mérete
	\item defektálók aránya 
	\item generáció szám (szimuláció hossza)
	\item kooperáló sejtek termelési költsége 
	\item diffúziós távolság mérete
	\item akarja-e a felhasználó, hogy a sejtek osztódásra legyenek képesek
\end{itemize}

\begin{figure}[ht!]
	\centering
	\captionsetup{justification=centering}
	\begin{tabular}{cc}
		\includegraphics[width=0.47\linewidth]{images/EGTIB}
		&
		\includegraphics[width=0.47\linewidth]{images/VisualizationDiagram}
	\end{tabular}
	\caption{Bal: vizualizációs oldal, Voronoi diagram, paraméterek. Jobb: a populáció változása generációnként adott paraméterekre}	
	\label{fig:VisualizationDiagram}
\end{figure}

A paraméterlista alatt található az új Voronoi diagramot generáló gomb is. Erre szükség van, mivel minden paraméter változásnál a Voronoi diagramot újra kirajzolni túlságosan költséges lenne és nagyon belassítani az oldalt, ezzel rontva a felhasználói élményt. A szimuláció elindításáért felelős gomb is itt kapott helyet, amely a szimuláció során megállít és folytat gombra cserélődik, attól függően, hogy a szimulációt megállítjuk-e. Amennyiben a felhasználó lusta lenne letekerni az oldal aljára, elhelyeztünk számára egy statisztikához ugró gombot is. Ha a felhasználó egy kicsikét leleményes, akkor rájön arra is, hogy amennyiben megállítja a szimuláció lejátszását, a Voronoi diagram alatt elhelyezett progress bar segítségével tekergetheti a szimulációt, pont úgy mint egy filmet.
Megszorítása ezen oldalnak, hogy 500 sejtnél többet nem lehet vele kirajzoltatni, illetve szimulálni, mert annak kirajzolása túlságosan költséges, a felhasználó csak annyit érzékelne, hogy az oldal megfagyott.

\paragraph{Szimuláció}- erre az oldalra (\ref{fig:SimulationFunctionDiagrams} ábra) kerültek az átlag felhasználónak nem sokat mondó paraméterek, valamint a sejtek száma is csak annyira korlátozott, amennyit a szerver képes szimulálni (max. 2000 sejt). Első szembeötlő eltérés a vizualizációs oldalhoz képest az, hogy itt már nincs Voronoi diagram, többek között ezért sincs annyira megkötve a sejtek maximális száma. Itt már nem kerül kirajzolásra a szimuláció, de természetesen a statisztikás grafikon itt is megjelenik. A felhasználó belenyúlhat az alábbi paraméterekbe is ezen az oldalon:
\begin{itemize}
	\item a V függvény meredeksége
	\item a V függvény áthajlási pontjának helye
	\item a gradiens alakja
	\item a gradiens meredeksége az áthajlási pontban
\end{itemize}
Mivel ezek csak nyers számok, ezért jó ötletnek gondoltuk azt, hogy a  V (\ref{eq:payoffGradient} képlet) és g (\ref{eq:diffGradient} képlet) függvényeket jelenítsük meg. Ezen grafikonok elhelyezése egyszerű volt, hisz a Voronoi diagram helyét vették át. Itt a paraméterek változtatása interaktív, ami annyit jelent, hogy amint a paraméter értékét átírjuk, úgy a grafikon is annak megfelelően változik.

Eléggé repetitívvé válik a felhasználó munkája amennyiben hasonló paraméterekre szeretne szimulációkat végezni, így az a lehetősége is megvan, hogy bizonyos paramétereket nem csak számként, hanem az alábbi formában is megadjon: 0.1:0.1:1. Ez azt jelenti, hogy 0.1-től indulva 0.1-esével egészen 1-ig minden értéket felvesz az adott paraméter és azon szimulációkat kéri le a szervertől.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=90mm]{images/SimulationFunctionDiagrams}
	\vspace*{1mm}
	\caption{A V és g függvények alakja adott paraméterekre}
	\label{fig:SimulationFunctionDiagrams}
\end{figure}


\paragraph{Eredmények}- kezdetben már azzal is megelégedtünk, ha egy szimulációt képesek voltunk megjeleníteni, viszont egy idő után azt vettük észre, hogy milyen jó lenne ha ezeket nem kellene mindig újra és újra generálni. Így született meg az eredményeket tartalmazó rész mely megjeleníti az oldalon futtatott szimulációkat egy error bar segítségével. Mivel a bemeneti paraméterek eléggé változatosak lehetnek, így valamilyen szinten ezen adatokat a megjelenítés során szűrni kell. Ezért a felhasználó ezt köteles is megtenni mielőtt az eredményeket megtekintené, az alábbiak szerint:
\begin{itemize}
	\item defektáló sejtek aránya
	\item kooperálási költség 
	\item interakció távolsága
\end{itemize}
Ezen adatok megadása után, az összes olyan szimuláció mely kielégíti a feltételeket egyesítve lesz egy grafikonon (Ábra \ref{fig:SimulationResults}).

\begin{figure}[ht!]
	\centering
	\includegraphics[width=90mm]{images/SimulationResults}
	\vspace*{1mm}
	\caption{Eddigi szimulációk eredményei}
	\label{fig:SimulationResults}
\end{figure}


\section{Felhasznált technológiák}

Annak ellenére, hogy az alkalmazás egyszerűnek tűnik egyáltalán nem az. A következőkben röviden ismertetjük a kliens oldali technológiákat (ezek részletesebben megtalálhatóak a {\color{red} Réka ref} dolgozatban), és valamivel részletesebben a szerver oldalit. Kiemeljük a folyamatos integrációt és annak megvalósításának lépéseit, valamint a tesztelési folyamatot és környezetet is ismertetjük.

\subsection{Kliens oldal}

Kliens oldalon a technológiák felhozatala eléggé változatos. Először is egy weboldal jól kell kinézzen és ezen feladatot a \textbf{Bootstrap} (\cite{soft:bootstrap}) keretrendszer tökéletesen ki is elégíti. Dinamikus oldalt lehet vele létrehozni, bármilyen eszközt együttesen lehet kezelni vele, nem csak desktopon de mobil eszközökön is jól néz ki az oldal. Kezdetben kliens oldalon nem nagyon volt bármiféle struktúra a JavaScriptben és elég hamar rá is jöttünk, hogy ez egy hatalmas probléma, a kód elég hamar átláthatatlan lett. Ezért átálltunk \textbf{AngularJS}-re (\cite{soft:angular}), mellyel már sokkal olvashatóbb kódot sikerült létrehoznunk, egyszerűbbé tette a kód bővítését is és az oldal dinamikussága is nőtt (pl. megjelentek az alertek). A Voronoi diagram megjelenítéséért a \textbf{Paper.js} (\cite{soft:paper}) a felelős, valamint itt is jelen van a Voronoi adatszerkezetet feldolgozó modul (\cite{soft:voronoiModule}). A grafikonok kirajzolására több keretrendszert is használunk. Ez azért van, mert ismertünk már egyet ami az adott feladatot kielégítette, viszont a későbbiekben új típusú diagramok jöttek be, melyekhez, mint kiderült, új keretrendszerre volt szükségünk. Így alakult, hogy a Voronoi diagram alatti grafikont a \textbf{Highcharts} (\cite{soft:highcharts}) segítségével, a V és g függvényeket (\ref{fig:SimulationFunctionDiagrams}) az AngularJS grafikonjaival, míg az error bart (\ref{fig:SimulationResults}) a \textbf{Plotly.js} (\cite{soft:plotly}) segítségével rajzoltuk ki.

\subsection{Szerver oldal}

\paragraph{NodeJS} - már a projekt kezdetekor biztosak voltunk benne, hogy egy könnyen és bárki által elérhető alkalmazásra lesz szükség, így nem volt kérdéses az, hogy webes felületet akarunk. Ezután már csak az volt a kérdéses, hogy számunkra milyen környezet lenne a legkényelmesebb, amely ha szükség van rá könnyen skálázható is. Végül a \textit{NodeJS}-re (\cite{soft:node}) esett a választásunk, hiszen ez egy egyszerű felület skálázható hálózati alkalmazások írására, valamint egy nagyon egyszerű és elterjedt nyelvet használ, a \textit{JavasSript}et. Keretrendszernek a sokak által ismert és használt \textbf{ExpressJS}-t (\cite{soft:express}) választottuk.

Tehát a szoftver egy szerverből és egy kliensből áll, melyek közötti kommunikáció a már jól megszokott HTTP-vel folyik. A fejlesztés során bizonyos szimulációs adatok JSON-beli küldözgetése túl nagy feladatnak bizonyult, így ezt más úton kellett megoldanunk. Itt megemlítenénk azt is, hogy a szerver oldalon folyik az erőforrás igényes számítások nagy része.

\paragraph{WebSocket} - olyan technológia, amely kétirányú kommunikációs csatornák kiépítését teszi lehetővé egyetlen TCP socketen keresztül. A webböngészőben futó alkalmazás képes a szerverrel való kétirányú kommunikációra (\cite{wiki:Websocket}). A már említett problémás nagyságú adatok küldözgetése ezen keresztül folyik (az [\ref{ch:appendix}] függelékben látható, hogy már 56 cella esetén is elég méretes egy üzenet. Válaszként a kliens ebből kap vissza generáció számnyit, ami 200 cella és 20 generáció esetén már elég terjedelmes üzenet).

\paragraph{Voronoi} - említettük, hogy \textit{Voronoi} diagramokkal ábrázoljuk a sejteket, így szükségünk volt egy Voronoi modulra is (\cite{soft:voronoiModule}). Ez a modul egy JavaScript implementációja Steven J. Fortune algoritmusának, mely hatékonyon dolgozik Voronoi diagramokkal, viszont csak az adatszerkezettel foglalkozik, nem képes ki is rajzolni azt.

\paragraph{MongoDB} - webalkalmazásról lévén szó szükség van egy adatbázisra is ahol a szesszió adatait el lehet tárolni, erre a \textit{MongoDB} (\cite{soft:mongodb}) jelentette a megoldást. A szimulációs eredmények lementése is ide történik, és természetesen az eredmények oldal kigenerálása során is innen vesszük ki az adatokat.

Miért pont MongoDB? Elsősorban azért, mert a Heroku platformja ingyenesen szolgáltatja számunkra és könnyű bekonfigurálni. De a legfőbb ok az, hogy az adataink JavaScript objektumokként vannak reprezentálva és a MongoDB adott számunkra egy olyan környezetet amelyben nagyon egyszerű dolgozni. Nem volt szükségünk tervezésre, hogyan nézzenek ki a relációs táblák (hisz nincs), valamint a fejlesztés során ha az objektum bármilyen szinten is változott, annak lementése ugyan olyan maradt.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=\linewidth]{images/SimulationProcess}
	\caption{Szekvencia diagram. A szimulálási folyamat lépései}
	\label{fig:SimulationProcess}
\end{figure}

\subsection{Felhőbe vele}

Mivel az alkalmazásunk egy webalkalmazás, szükségünk volt egy szerverre, ahova ezt kitelepíthetjük. Míg régen ez egy saját szerverre telepítették mely egy statikus IP címmel rendelkezett, addig mára már sokkal könnyebb ha ezt inkább egy felhőbe rakjuk. Több ingyenesen használható felhő is létezik már, a mi választásunk a \textit{Heroku} lett (az alábbi linken érhető el az alkalmazásunk: \url{https://egtib.herokuapp.com/}).

\paragraph{Heroku} - a Heroku egy PaaS típusú felhőszolgáltató, ami annyit jelent, hogy platformot és kész szolgáltatásokat nyújt. Elég volt csak azt megmondani, hogy egy NodeJS alapú szervert akarunk üzemeltetni, ahhoz kiválasztottunk egy akármilyen adatbázist (ez lett a MongoDB), és már kész is, lehet is kitelepíteni az alkalmazást.

\subsection{Folyamatos integráció}

A folyamatos integráció egy olyan fejlesztési folyamat, ami megkönnyíti a csapatmunkában történő fejlesztést és folytonossá teszi azt. A csapat tagjai már a kezdetektől összeillesztik a kódjukat, ezek buildelése és tesztelése pedig automatikussá válik, ezzel is könnyítve a fejlesztők feladatát és gyorsabbá téve a fejlesztést.

\paragraph{TravisCI} - mivel mi sem szerettük a kitelepítést kézzel elvégezni, ezért, és persze a már fentebb is említett hasznos funkcióért is, automatizáltuk a fejlesztést a \textit{TravisCI} (\cite{soft:travis}) segítségével. A TravisCI egy folytonos integrációs platform, mely könnyen összeköthető github projektekkel, és minden egyes alkalmazás frissítéskor képes előre megadott parancsokat elvégezni (tesztelés, kitelepítés).

\paragraph{Docker} - ha az alkalmazásunkat egy \textit{Docker}-be (\cite{soft:docker}) rakjuk, akkor biztosíthatjuk azt, hogy bárhova is kerül az alkalmazásunk, mindig ugyanazon körülmények között fog futni, ez a Docker tulajdonsága.

\subsection{Tesztelés}

Semmilyen kódot nem adhatunk ki a kezünkből, ha annak minősége nincs valahogyan biztosítva. Ezt a minőséget tesztekkel lehet valamilyen szinten biztosítani, amit mi is megpróbáltunk. Köszönhetően a TravisCI-nak a tesztelés beépítése a fejlesztési folyamatba könnyen ment. Minden egyes új verzió felkerülésekor a github repositoryba, a Travis lefuttatja a teszteket és jelezi, hogy ezek között van-e olyan amely megbukott, illetve rak egy zöld pipát ha mind átment. A unit tesztjeink a \textbf{Mocha} (\cite{soft:mocha}), míg az E2E tesztjeink a \textbf{TestCafe} (\cite{soft:testcafe}) keretrendszerekben íródtak. Ezek közül kiemeljük a TestCafet, mert ez egy olyan keretrendszer melynél nincs szükség böngésző driverre, egyenesen egy előre telepített böngészőt használ, illetve fel lehet venni vele kattintásokat, azaz ki lehet vele generálni a tesztesetet és nem kell hozzá kódot írni.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=\linewidth]{images/Architecture}
	\caption{A projekt architektúrája}
	\label{fig:Architecture}
\end{figure}
